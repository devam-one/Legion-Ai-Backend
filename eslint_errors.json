[{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\drizzle.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\next.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\ai\\generate\\image\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":66,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":66,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// app/api/ai/generate/image/route.ts (UPDATED with AI SDK)\r\nimport { auth } from '@clerk/nextjs/server';\r\nimport { NextResponse } from 'next/server';\r\nimport { db } from '@/lib/db';\r\nimport { ai_generations } from '@/db/schema';\r\nimport { generateImageSchema } from '@/lib/validations/ai';\r\nimport { CREDIT_COSTS, deductCredits, hasEnoughCredits, getCreditBalance } from '@/lib/utils/credits';\r\nimport { generateAIImage } from '@/lib/ai/providers';\r\nimport { eq, sql } from 'drizzle-orm';\r\nimport { z } from 'zod';\r\nimport { aiGenerationLimit } from '@/lib/utils/ratelimit';\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    // 1. Authentication\r\n    const { userId } = await auth();\r\n\r\n    if (!userId) {\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 2. Rate limiting (ADD THIS)\r\n    const { success, remaining, reset } = await aiGenerationLimit.limit(userId);\r\n\r\n    if (!success) {\r\n      return NextResponse.json(\r\n        { \r\n          error: 'Rate limit exceeded',\r\n          remaining,\r\n          reset: new Date(reset).toISOString(),\r\n        },\r\n        { \r\n          status: 429,\r\n          headers: {\r\n            'X-RateLimit-Remaining': remaining.toString(),\r\n            'X-RateLimit-Reset': reset.toString(),\r\n          }\r\n        }\r\n      );\r\n    }\r\n\r\n    // 2. Parse and validate input\r\n    const body = await req.json();\r\n    const validatedInput = generateImageSchema.parse(body);\r\n\r\n    // 3. Check if user has enough credits\r\n    const requiredCredits = CREDIT_COSTS.image;\r\n    const hasCredits = await hasEnoughCredits(userId, requiredCredits);\r\n\r\n    if (!hasCredits) {\r\n      return NextResponse.json(\r\n        { \r\n          error: 'Insufficient credits',\r\n          required: requiredCredits,\r\n        },\r\n        { status: 402 }\r\n      );\r\n    }\r\n\r\n    // 4. Deduct credits (atomic)\r\n    try {\r\n      await deductCredits(userId, requiredCredits);\r\n    } catch (error) {\r\n      return NextResponse.json(\r\n        { error: 'Failed to deduct credits' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    // 5. Create generation record\r\n    const [generation] = await db.insert(ai_generations)\r\n      .values({\r\n        user_id: userId,\r\n        prompt: validatedInput.prompt,\r\n        generation_type: 'image',\r\n        credits_cost: requiredCredits,\r\n        status: 'processing',\r\n        is_public: true,\r\n      })\r\n      .returning();\r\n\r\n    // 6. Generate image with Vercel AI SDK (supports multiple providers)\r\n    const result = await generateAIImage(validatedInput.prompt, 'google');\r\n\r\n    if (!result.success) {\r\n      // Mark as failed\r\n      await db.update(ai_generations)\r\n        .set({ status: 'failed' })\r\n        .where(eq(ai_generations.id, generation.id));\r\n\r\n      // Refund credits\r\n      await sql`\r\n        UPDATE users \r\n        SET credits_balance = credits_balance + ${requiredCredits}\r\n        WHERE id = ${userId}\r\n      `;\r\n\r\n      return NextResponse.json(\r\n        { error: result.error || 'Generation failed' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    // 7. Update with result\r\n    const [updatedGeneration] = await db.update(ai_generations)\r\n      .set({\r\n        result_url: result.url,\r\n        thumbnail_url: result.url,\r\n        status: 'completed',\r\n      })\r\n      .where(eq(ai_generations.id, generation.id))\r\n      .returning();\r\n\r\n    // 8. Return success\r\n    return NextResponse.json({\r\n      success: true,\r\n      generation: {\r\n        id: updatedGeneration.id,\r\n        prompt: updatedGeneration.prompt,\r\n        result_url: updatedGeneration.result_url,\r\n        credits_cost: updatedGeneration.credits_cost,\r\n        created_at: updatedGeneration.created_at,\r\n      },\r\n      credits_remaining: await getCreditBalance(userId),\r\n    });\r\n\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      return NextResponse.json(\r\n        { error: 'Invalid input', details: error.issues },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    console.error('Image generation error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\ai\\generate\\text\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":52,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":52,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// app/api/ai/generate/text/route.ts\r\nimport { auth } from '@clerk/nextjs/server';\r\nimport { NextResponse } from 'next/server';\r\nimport { db } from '@/lib/db';\r\nimport { ai_generations } from '@/db/schema';\r\nimport { CREDIT_COSTS, deductCredits, hasEnoughCredits, getCreditBalance } from '@/lib/utils/credits';\r\nimport { generateAIText } from '@/lib/ai/providers';\r\nimport { eq, sql } from 'drizzle-orm';\r\nimport { z } from 'zod';\r\n\r\n// Input validation\r\nconst generateTextSchema = z.object({\r\n  prompt: z.string()\r\n    .min(3, 'Prompt must be at least 3 characters')\r\n    .max(2000, 'Prompt is too long'),\r\n  provider: z.enum(['openai', 'gemini', 'gptMini']).default('gemini'), // Gemini is cheaper\r\n});\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    // 1. Authentication\r\n    const { userId } = await auth();\r\n\r\n    if (!userId) {\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 2. Validate input\r\n    const body = await req.json();\r\n    const validatedInput = generateTextSchema.parse(body);\r\n\r\n    // 3. Check credits\r\n    const requiredCredits = CREDIT_COSTS.text;\r\n    const hasCredits = await hasEnoughCredits(userId, requiredCredits);\r\n\r\n    if (!hasCredits) {\r\n      return NextResponse.json(\r\n        { \r\n          error: 'Insufficient credits',\r\n          required: requiredCredits,\r\n        },\r\n        { status: 402 }\r\n      );\r\n    }\r\n\r\n    // 4. Deduct credits\r\n    try {\r\n      await deductCredits(userId, requiredCredits);\r\n    } catch (error) {\r\n      return NextResponse.json(\r\n        { error: 'Failed to deduct credits' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    // 5. Create generation record\r\n    const [generation] = await db.insert(ai_generations)\r\n      .values({\r\n        user_id: userId,\r\n        prompt: validatedInput.prompt,\r\n        generation_type: 'text',\r\n        credits_cost: requiredCredits,\r\n        status: 'processing',\r\n        is_public: true,\r\n      })\r\n      .returning();\r\n\r\n    // 6. Generate text with Vercel AI SDK\r\n    const result = await generateAIText(\r\n      validatedInput.prompt, \r\n      validatedInput.provider\r\n    );\r\n\r\n    if (!result.success) {\r\n      // Mark as failed and refund\r\n      await db.update(ai_generations)\r\n        .set({ status: 'failed' })\r\n        .where(eq(ai_generations.id, generation.id));\r\n\r\n      await db.execute(sql`\r\n        UPDATE users \r\n        SET credits_balance = credits_balance + ${requiredCredits}\r\n        WHERE id = ${userId}\r\n      `);\r\n\r\n      return NextResponse.json(\r\n        { error: result.error || 'Generation failed' },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    // 7. Store text result (we'll store it in result_url as plain text for now)\r\n    const [updatedGeneration] = await db.update(ai_generations)\r\n      .set({\r\n        result_url: result.text, // Store text directly\r\n        status: 'completed',\r\n      })\r\n      .where(eq(ai_generations.id, generation.id))\r\n      .returning();\r\n\r\n    // 8. Return success\r\n    return NextResponse.json({\r\n      success: true,\r\n      generation: {\r\n        id: updatedGeneration.id,\r\n        prompt: updatedGeneration.prompt,\r\n        text: updatedGeneration.result_url, // The generated text\r\n        credits_cost: updatedGeneration.credits_cost,\r\n        created_at: updatedGeneration.created_at,\r\n      },\r\n      credits_remaining: await getCreditBalance(userId),\r\n    });\r\n\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      return NextResponse.json(\r\n        { error: 'Invalid input', details: error.issues },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    console.error('Text generation error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\ai\\generate\\video\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\ai\\history\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'users' is defined but never used.","line":5,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// app/api/ai/history/route.ts\r\nimport { auth } from '@clerk/nextjs/server';\r\nimport { NextResponse } from 'next/server';\r\nimport { db } from '@/lib/db';\r\nimport { ai_generations, users } from '@/db/schema';\r\nimport { eq, desc } from 'drizzle-orm';\r\nimport { sql } from 'drizzle-orm';\r\n\r\nexport async function GET(req: Request) {\r\n  try {\r\n    // 1. Authentication\r\n    const { userId } = await auth();\r\n\r\n    if (!userId) {\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 2. Parse pagination parameters from URL\r\n    const { searchParams } = new URL(req.url);\r\n    const page = parseInt(searchParams.get('page') || '1');\r\n    const limit = parseInt(searchParams.get('limit') || '20');\r\n    const status = searchParams.get('status'); // 'completed', 'processing', 'failed'\r\n    const type = searchParams.get('type'); // 'image', 'video', 'text'\r\n\r\n    // Validate pagination\r\n    if (page < 1 || limit < 1 || limit > 100) {\r\n      return NextResponse.json(\r\n        { error: 'Invalid pagination parameters' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const offset = (page - 1) * limit;\r\n\r\n    // 3. Build query with filters\r\n    let query = db\r\n      .select({\r\n        id: ai_generations.id,\r\n        prompt: ai_generations.prompt,\r\n        generation_type: ai_generations.generation_type,\r\n        result_url: ai_generations.result_url,\r\n        thumbnail_url: ai_generations.thumbnail_url,\r\n        credits_cost: ai_generations.credits_cost,\r\n        status: ai_generations.status,\r\n        is_public: ai_generations.is_public,\r\n        created_at: ai_generations.created_at,\r\n      })\r\n      .from(ai_generations)\r\n      .where(eq(ai_generations.user_id, userId));\r\n\r\n    // Apply filters if provided\r\n    if (status) {\r\n      query = query.where(eq(ai_generations.status, status));\r\n    }\r\n    if (type) {\r\n      query = query.where(eq(ai_generations.generation_type, type));\r\n    }\r\n\r\n    // 4. Fetch generations with pagination\r\n    const generations = await query\r\n      .orderBy(desc(ai_generations.created_at))\r\n      .limit(limit)\r\n      .offset(offset);\r\n\r\n    // 5. Get total count for pagination metadata\r\n    const [{ count }] = await db\r\n      .select({ count: sql`count(*)::int` })\r\n      .from(ai_generations)\r\n      .where(eq(ai_generations.user_id, userId));\r\n\r\n    const totalPages = Math.ceil(count / limit);\r\n\r\n    // 6. Return paginated response\r\n    return NextResponse.json({\r\n      data: generations,\r\n      pagination: {\r\n        page,\r\n        limit,\r\n        total: count,\r\n        totalPages,\r\n        hasMore: page < totalPages,\r\n      },\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('History fetch error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\ai\\status\\[jobID]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\auth\\webhooks\\clerk\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\feed\\explore\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\feed\\home\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\feed\\user\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\health\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\payments\\create-checkout\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\payments\\packages\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\payments\\stripe\\create-checkout\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\payments\\stripe\\webhook\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\payments\\woo\\webhook\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\posts\\[postId]\\bookmark\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used.","line":6,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// app/api/posts/[postId]/bookmark/route.ts\r\nimport { auth } from '@clerk/nextjs/server';\r\nimport { NextResponse } from 'next/server';\r\nimport { db } from '@/lib/db';\r\nimport { bookmarks, posts } from '@/db/schema';\r\nimport { eq, and, sql } from 'drizzle-orm';\r\n\r\n// POST - Bookmark a post\r\nexport async function POST(\r\n  req: Request,\r\n  { params }: { params: { postId: string } }\r\n) {\r\n  try {\r\n    // 1. Authentication\r\n    const { userId } = await auth();\r\n\r\n    if (!userId) {\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 2. Verify post exists\r\n    const post = await db.query.posts.findFirst({\r\n      where: eq(posts.id, params.postId),\r\n    });\r\n\r\n    if (!post) {\r\n      return NextResponse.json(\r\n        { error: 'Post not found' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // 3. Check if already bookmarked\r\n    const existingBookmark = await db.query.bookmarks.findFirst({\r\n      where: and(\r\n        eq(bookmarks.post_id, params.postId),\r\n        eq(bookmarks.user_id, userId)\r\n      ),\r\n    });\r\n\r\n    if (existingBookmark) {\r\n      return NextResponse.json(\r\n        { error: 'Already bookmarked' },\r\n        { status: 409 }\r\n      );\r\n    }\r\n\r\n    // 4. Create bookmark\r\n    const [bookmark] = await db.insert(bookmarks)\r\n      .values({\r\n        post_id: params.postId,\r\n        user_id: userId,\r\n      })\r\n      .returning();\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      bookmarked: true,\r\n      bookmark_id: bookmark.id,\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Bookmark error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// DELETE - Remove bookmark\r\nexport async function DELETE(\r\n  req: Request,\r\n  { params }: { params: { postId: string } }\r\n) {\r\n  try {\r\n    // 1. Authentication\r\n    const { userId } = await auth();\r\n\r\n    if (!userId) {\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 2. Delete bookmark\r\n    const [deletedBookmark] = await db\r\n      .delete(bookmarks)\r\n      .where(\r\n        and(\r\n          eq(bookmarks.post_id, params.postId),\r\n          eq(bookmarks.user_id, userId)\r\n        )\r\n      )\r\n      .returning();\r\n\r\n    if (!deletedBookmark) {\r\n      return NextResponse.json(\r\n        { error: 'Bookmark not found' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      bookmarked: false,\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Unbookmark error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\posts\\[postId]\\comment\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\posts\\[postId]\\like\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'like' is assigned a value but never used.","line":51,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":51,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// app/api/posts/[postId]/like/route.ts\r\nimport { auth } from '@clerk/nextjs/server';\r\nimport { NextResponse } from 'next/server';\r\nimport { db } from '@/lib/db';\r\nimport { likes, posts } from '@/db/schema';\r\nimport { eq, and, sql } from 'drizzle-orm';\r\n\r\nexport async function POST(\r\n  req: Request,\r\n  { params }: { params: { postId: string } }\r\n) {\r\n  try {\r\n    // 1. Authentication\r\n    const { userId } = await auth();\r\n\r\n    if (!userId) {\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 2. Verify post exists\r\n    const post = await db.query.posts.findFirst({\r\n      where: eq(posts.id, params.postId),\r\n    });\r\n\r\n    if (!post) {\r\n      return NextResponse.json(\r\n        { error: 'Post not found' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // 3. Check if already liked\r\n    const existingLike = await db.query.likes.findFirst({\r\n      where: and(\r\n        eq(likes.post_id, params.postId),\r\n        eq(likes.user_id, userId)\r\n      ),\r\n    });\r\n\r\n    if (existingLike) {\r\n      return NextResponse.json(\r\n        { error: 'Already liked' },\r\n        { status: 409 }\r\n      );\r\n    }\r\n\r\n    // 4. Create like\r\n    const [like] = await db.insert(likes)\r\n      .values({\r\n        post_id: params.postId,\r\n        user_id: userId,\r\n      })\r\n      .returning();\r\n\r\n    // 5. Get like count\r\n    const [{ count }] = await db\r\n      .select({ count: sql`count(*)::int` })\r\n      .from(likes)\r\n      .where(eq(likes.post_id, params.postId));\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      liked: true,\r\n      like_count: count,\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Like error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\nexport async function DELETE(\r\n  req: Request,\r\n  { params }: { params: { postId: string } }\r\n) {\r\n  try {\r\n    // 1. Authentication\r\n    const { userId } = await auth();\r\n\r\n    if (!userId) {\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 2. Delete like\r\n    const [deletedLike] = await db\r\n      .delete(likes)\r\n      .where(\r\n        and(\r\n          eq(likes.post_id, params.postId),\r\n          eq(likes.user_id, userId)\r\n        )\r\n      )\r\n      .returning();\r\n\r\n    if (!deletedLike) {\r\n      return NextResponse.json(\r\n        { error: 'Like not found' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // 3. Get updated like count\r\n    const [{ count }] = await db\r\n      .select({ count: sql`count(*)::int` })\r\n      .from(likes)\r\n      .where(eq(likes.post_id, params.postId));\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      liked: false,\r\n      like_count: count,\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Unlike error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\posts\\create\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\user\\[username]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\user\\bookmarks\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\user\\credits\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\user\\following\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sql' is defined but never used.","line":6,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// app/api/user/following/route.ts\r\nimport { auth } from '@clerk/nextjs/server';\r\nimport { NextResponse } from 'next/server';\r\nimport { db } from '@/lib/db';\r\nimport { follows, users } from '@/db/schema';\r\nimport { eq, and, sql } from 'drizzle-orm';\r\nimport { z } from 'zod';\r\n\r\n// Input validation\r\nconst followSchema = z.object({\r\n  following_id: z.string().min(1, 'User ID required'),\r\n});\r\n\r\n// POST - Follow a user\r\nexport async function POST(req: Request) {\r\n  try {\r\n    // 1. Authentication\r\n    const { userId } = await auth();\r\n\r\n    if (!userId) {\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 2. Validate input\r\n    const body = await req.json();\r\n    const validatedInput = followSchema.parse(body);\r\n\r\n    // 3. Check if trying to follow self\r\n    if (userId === validatedInput.following_id) {\r\n      return NextResponse.json(\r\n        { error: 'Cannot follow yourself' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // 4. Verify target user exists\r\n    const targetUser = await db.query.users.findFirst({\r\n      where: eq(users.id, validatedInput.following_id),\r\n    });\r\n\r\n    if (!targetUser) {\r\n      return NextResponse.json(\r\n        { error: 'User not found' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // 5. Check if already following\r\n    const existingFollow = await db.query.follows.findFirst({\r\n      where: and(\r\n        eq(follows.follower_id, userId),\r\n        eq(follows.following_id, validatedInput.following_id)\r\n      ),\r\n    });\r\n\r\n    if (existingFollow) {\r\n      return NextResponse.json(\r\n        { error: 'Already following this user' },\r\n        { status: 409 }\r\n      );\r\n    }\r\n\r\n    // 6. Create follow relationship\r\n    const [follow] = await db.insert(follows)\r\n      .values({\r\n        follower_id: userId,\r\n        following_id: validatedInput.following_id,\r\n      })\r\n      .returning();\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      following: true,\r\n      follow_id: follow.id,\r\n    });\r\n\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      return NextResponse.json(\r\n        { error: 'Invalid input', details: error.issues },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    console.error('Follow error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// DELETE - Unfollow a user\r\nexport async function DELETE(req: Request) {\r\n  try {\r\n    // 1. Authentication\r\n    const { userId } = await auth();\r\n\r\n    if (!userId) {\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized' },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // 2. Get following_id from query params\r\n    const { searchParams } = new URL(req.url);\r\n    const following_id = searchParams.get('following_id');\r\n\r\n    if (!following_id) {\r\n      return NextResponse.json(\r\n        { error: 'following_id required' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // 3. Delete follow relationship\r\n    const [deletedFollow] = await db\r\n      .delete(follows)\r\n      .where(\r\n        and(\r\n          eq(follows.follower_id, userId),\r\n          eq(follows.following_id, following_id)\r\n        )\r\n      )\r\n      .returning();\r\n\r\n    if (!deletedFollow) {\r\n      return NextResponse.json(\r\n        { error: 'Follow relationship not found' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      following: false,\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Unfollow error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// GET - Get following/followers list\r\nexport async function GET(req: Request) {\r\n  try {\r\n    // Get user ID from query params (to view someone else's follows)\r\n    const { searchParams } = new URL(req.url);\r\n    const targetUserId = searchParams.get('user_id');\r\n    const type = searchParams.get('type') || 'following'; // 'following' or 'followers'\r\n\r\n    if (!targetUserId) {\r\n      return NextResponse.json(\r\n        { error: 'user_id required' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    if (type === 'following') {\r\n      // Get users that targetUserId follows\r\n      const following = await db\r\n        .select({\r\n          id: users.id,\r\n          username: users.username,\r\n          avatar_url: users.avatar_url,\r\n          bio: users.bio,\r\n        })\r\n        .from(follows)\r\n        .innerJoin(users, eq(follows.following_id, users.id))\r\n        .where(eq(follows.follower_id, targetUserId));\r\n\r\n      return NextResponse.json({\r\n        data: following,\r\n        count: following.length,\r\n      });\r\n    } else {\r\n      // Get users that follow targetUserId\r\n      const followers = await db\r\n        .select({\r\n          id: users.id,\r\n          username: users.username,\r\n          avatar_url: users.avatar_url,\r\n          bio: users.bio,\r\n        })\r\n        .from(follows)\r\n        .innerJoin(users, eq(follows.follower_id, users.id))\r\n        .where(eq(follows.following_id, targetUserId));\r\n\r\n      return NextResponse.json({\r\n        data: followers,\r\n        count: followers.length,\r\n      });\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Follows fetch error:', error);\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\api\\user\\profile\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\db\\schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\lib\\ai\\providers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\lib\\db.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\lib\\env.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\lib\\redis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\lib\\storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\lib\\utils\\credits.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\lib\\utils\\feed.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[306,309],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[306,309],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[529,532],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[529,532],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[789,792],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[789,792],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1062,1065],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1062,1065],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1323,1326],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1323,1326],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1558,1561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1558,1561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// lib/utils/feed-cache.ts\r\nimport { redis } from '@/lib/redis';\r\n\r\nconst CACHE_TTL = {\r\n  HOME_FEED: 5 * 60, // 5 minutes\r\n  EXPLORE_FEED: 10 * 60, // 10 minutes\r\n  USER_FEED: 15 * 60, // 15 minutes\r\n};\r\n\r\n/**\r\n * Cache home feed for a user\r\n */\r\nexport async function cacheHomeFeed(userId: string, feed: any[]) {\r\n  const key = `feed:home:${userId}`;\r\n  await redis.setex(key, CACHE_TTL.HOME_FEED, JSON.stringify(feed));\r\n}\r\n\r\n/**\r\n * Get cached home feed\r\n */\r\nexport async function getCachedHomeFeed(userId: string): Promise<any[] | null> {\r\n  const key = `feed:home:${userId}`;\r\n  const cached = await redis.get(key);\r\n  return cached ? JSON.parse(cached as string) : null;\r\n}\r\n\r\n/**\r\n * Cache explore feed (shared across all users)\r\n */\r\nexport async function cacheExploreFeed(feed: any[], sortBy: string = 'recent') {\r\n  const key = `feed:explore:${sortBy}`;\r\n  await redis.setex(key, CACHE_TTL.EXPLORE_FEED, JSON.stringify(feed));\r\n}\r\n\r\n/**\r\n * Get cached explore feed\r\n */\r\nexport async function getCachedExploreFeed(sortBy: string = 'recent'): Promise<any[] | null> {\r\n  const key = `feed:explore:${sortBy}`;\r\n  const cached = await redis.get(key);\r\n  return cached ? JSON.parse(cached as string) : null;\r\n}\r\n\r\n/**\r\n * Cache user profile feed\r\n */\r\nexport async function cacheUserFeed(targetUserId: string, feed: any[]) {\r\n  const key = `feed:user:${targetUserId}`;\r\n  await redis.setex(key, CACHE_TTL.USER_FEED, JSON.stringify(feed));\r\n}\r\n\r\n/**\r\n * Get cached user feed\r\n */\r\nexport async function getCachedUserFeed(targetUserId: string): Promise<any[] | null> {\r\n  const key = `feed:user:${targetUserId}`;\r\n  const cached = await redis.get(key);\r\n  return cached ? JSON.parse(cached as string) : null;\r\n}\r\n\r\n/**\r\n * Invalidate user's home feed cache (when they post/like/follow)\r\n */\r\nexport async function invalidateHomeFeed(userId: string) {\r\n  const key = `feed:home:${userId}`;\r\n  await redis.del(key);\r\n}\r\n\r\n/**\r\n * Invalidate explore feed cache (when new post is created)\r\n */\r\nexport async function invalidateExploreFeed() {\r\n  await redis.del('feed:explore:recent', 'feed:explore:popular');\r\n}\r\n\r\n/**\r\n * Invalidate user feed cache\r\n */\r\nexport async function invalidateUserFeed(userId: string) {\r\n  const key = `feed:user:${userId}`;\r\n  await redis.del(key);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\lib\\utils\\optimistic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\lib\\utils\\ratelimit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\learnt_dev\\anti-g\\rnr-legion\\legion-backend\\src\\lib\\validations\\ai.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
